<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Surround 丶海</title>
<meta name="description" content="這個世界對著你笑的人太多太多， 但真心包容你的卻太少太少" />
<link rel="shortcut icon" href="https://lseatao.github.io/8816/favicon.ico?v=1598020022125">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://lseatao.github.io/8816/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://lseatao.github.io/8816">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://lseatao.github.io/8816/images/avatar.png?v=1598020022125" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">Surround 丶海</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            
          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="#" target="_blank">Surround 丶海</a></div>
    <a class="rss" href="https://lseatao.github.io/8816/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">交互理论</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-08-16 / 9 min read
        </div>
        
        <div class="post-content yue">
          <p>费茨定律<br>
菲茨定律是指：到达目标的距离越长、交互元素的尺寸越小，花费的时间就越长。反之，到达目标的距离越短，交互元素的尺寸越大，那么总体花费的时间就越短，体验就越好。比如桌面系统的导航栏位置、鼠标右键、巨大的按钮，都是为了减少用户点击它的时间，提高效率。</p>
<p>设计中的应用</p>
<p>1.由于鼠标指针无法移出屏幕，会在到达屏幕边缘或角落就停止。因此，界面的四个边角可以比显示器中的其他位置更快地进行点击操作。我们能以最快速度移动鼠标，但仍然可以击中目标。这也就是为什么MacOS系统中始终将菜单栏置于屏幕的左上边缘，而不是当前程序的窗口上。</p>
<figure data-type="image" tabindex="1"><img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6Yrhgruar0FPj4d7dCN97z0PDcWG3OLCGGgvZwpBiaJwz6YAcHa3s3viblxw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></figure>
<p>2.当我们点击鼠标右键，菜单会紧贴着鼠标指针的位置出现。这样点击距离就会缩短，我们可以快速的进行选择操作。</p>
<p>3.移动端重要的按钮通常都会放置在方便用户点击的区域，这也就是为什么说3.5英寸手机的屏幕尺寸是最方便的尺寸。因为，用户的拇指可以不费力的点击屏幕大部分的区域，从而进行完美的单手操作。但随着人们需求的变化，屏幕的尺寸越来越大，方便用户能够在最短的时间内浏览更多的内容。</p>
<p>因此，各种新颖的交互手势慢慢出现，归根结底都是为了方便用户用最快速的、最有效率的方式进行操作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6YrhVgpJnot3cmVanqicWn5MZFbWLpRfmlsrpPAyvA6llmiaUic7T1jseAZCw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"><br>
总结<br>
随着被点击对象大小的增加、用户操作的起点与对象之间的距离减小，都会让用户操作的速度得到增加。不过，随之而来的还会有误操作等可能性。所以，我们要对交互元素的位置以及大小进行合理的分配。</p>
<p>席克定律</p>
<p>席克定律是指，用户做出决定所需的时间和精力会随着选择数量的增加而增加。因此，概括来说就是：少即是快！拿遥控器来举例，上面有很多的按钮。但常用的按钮就那么几个。所以其它按钮的出现会一定程度上干扰用户的使用。因此，苹果遥控器就做到了最简化。</p>
<figure data-type="image" tabindex="2"><img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6Yrh0YCcHCJr38jC9fRH0hDEzhjHpQiaEKyq3xhUO0H0x4YETkAJZKiciaEuw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></figure>
<p>设计中的应用</p>
<p>1.某些产品在新用户首次登录填写信息时，并没有将账号、密码、验证码等多种信息一口气展示出来。而是分步骤，引导用户一步步操作。掩盖复杂性，将复杂的流程分解为多个屏幕。例如：用户填写好手机号点击下一步后，再出现填写验证码的选项。</p>
<figure data-type="image" tabindex="3"><img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6YrhvibWEMexsO2pOo2bZcW1SibRHr0Wt58VvJEaHW16ic3YCq8ukPR8BQnBQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></figure>
<p>2.通讯录中的按字母排布虽然现在来看已经是习以为常的设计了，但设想一下：如果通讯录中的人名都不按照字母排布，而是毫无逻辑规整的堆在一起，我们还能快速的找到特定的联系人吗。而按照字母排布的方式，即使没有搜索功能我们也不难找到。</p>
<p>3.导航栏部分，可以与7±2法则搭配使用。他们的共同点就是减少导航内容的数量。如果导航栏上有十几二十几个选项，用户看到是会非常崩溃的。因此，简化内容或进行分类筛选，可以帮助用户提高使用效率。</p>
<figure data-type="image" tabindex="4"><img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6YrhiaRoZuic4nawciabwu6e4d2oiaW1JYhPumT2E7lOia7G6t63a5TN98qQjoQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></figure>
<p>总结<br>
核心理念就是：少即是快！给内容做减法，帮助用户筛选提炼关键内容，节省用户选择的时间。但定律的根本是简化操作流程，而不是彻底操作流程擅自帮用户做选择。所以，一些必要的操作或需要重点提示的内容依然是要让用户知晓的。</p>
<p>什么是格式塔原理</p>
<p>格式塔原则（分组原则）是描述人眼如何感知视觉元素的规则。原理旨在说明如何将复杂的场景简化为简单形状；或解释人眼如何将分散的元素归为同一图形，而不是单纯的独立元素。原理主要分为：相似度，连续性，封闭性、邻近性、对称性、连通性等。</p>
<p>设计中的应用</p>
<p>1.相似性：人眼倾向于将相似的元素之间建立联系，比如：形状、颜色、大小、属性相似等等，即使它们分隔很远。当人们看到这些特征相似的元素时，便会不自觉的将它们归为一组。</p>
<figure data-type="image" tabindex="5"><img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6YrhtduFMOGdhWfI3RFYfGu9UDLwTYUTPPRr7AuibBPoqrHB2tibClMItMDA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></figure>
<p>2.连续性：人眼遵循设计的路径，喜欢看到连续的视觉元素或设计形式而不是分离的对象。即使元素是分开的，但视觉有朝一个方向延续的能力。因此，我们会自然的把分离的元素连接在一起，使它看起来是朝着特定的方向。</p>
<p>banner或滚动的卡片样式常见的样式<br>
<img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6Yrh2a71M3PMPeazSUu4RoibkqogMqq3jvjZzibkoRayicyj2ZSxRicicjWxgYg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></p>
<p>3.封闭性：人眼更喜欢看到完整的形状，因此会自然地在缺损的元素上寻找完整性。如果某元素的整体是不完整的，用户可以通过自动填补缺失视觉信息的方式来感知其完整的形状。</p>
<figure data-type="image" tabindex="6"><img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6Yrh17XAdBpQYGfB5qg9MXx3uNgCBLtZnvuB83bN013Yxa5oIPJ45bIdlA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></figure>
<p>图形与字母尽管不完整，但我们也可以轻松的识别出熊猫与字母A</p>
<p>4.接近性：①我们的大脑会自然的将彼此靠近的对象关联起来。之所以会产生这种关联，是因为人脑天生就有将事物组织和分组的倾向。②同时，通过统一的视觉属性连接的方式将某些元素归为一组，使我们感知到组或块的存在，而不是零散的单独元素。<br>
<img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6YrhFRChy6qToALsGFg2LwMBUY3w8OBERsJCGXXcTzXVvWiaviaeVt0wv59w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></p>
<p>页面中的元素通过属性分配、间距或分割线等方式，将内容分配的井井有条。</p>
<p>5.对称性：人们倾向于将物体视为围绕其中心所形成的对称形状。对称会给我们一种稳固与有序感，这是我们出于本能去发现的。</p>
<figure data-type="image" tabindex="7"><img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6YrhMVXqibJlKDicR6eic2icibDibsGbzicWfwz4rHqA786uVQ3yoay5MyKIYibyXg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></figure>
<p>6.主体与背景：人们会自然地会将图像分为主体与背景两个部分。主体是悬浮在最上层的核心内容区域，而其余的则都是背景部分。在实际的设计当中，往往较小的元素是主体部分。</p>
<figure data-type="image" tabindex="8"><img src="https://mmbiz.qpic.cn/mmbiz_jpg/3DWMyLrQK93FomXvvxVU1tS6VhTk6YrhaqmMlhIgt4MYHvRfKaKe8VlMO6735hQDSicQsIQV9PYWXB7jvmdLLzw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></figure>
<p>7.共同命运：牵一发而动全身，无论元素放置的距离有多远或它们看起来有多不同，如果它们沿相同方向移动，则被认为彼此之间具有关联系，视为同一组。</p>
<figure data-type="image" tabindex="9"><img src="https://mmbiz.qpic.cn/mmbiz_gif/3DWMyLrQK93FomXvvxVU1tS6VhTk6YrhX9ziaF7Uvdzj2PnTANWtzolwrGV99Tfia0libvzWJn8d4Gt7ekicLDUWSw/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="" loading="lazy"></figure>
<p>总结<br>
格式塔原理中的内容看似基础，但越基础的内容往往越有效。它可以使我们的设计有据可依。可以帮助我们将复杂的信息内容合理组合与分配，让用户第一时间了解到其核心内容，提高效率。</p>
<p>什么是米勒定律</p>
<p>米勒定律，也可被称为7±2法则。指的是一般情况下用户对事物的短时记忆容量约为7个加减2个，也就是5至9个（受事物种类比如数字、字母或排布方式等多种因素影响）。如果超过这个数字，人脑的认知负荷便开始增加。</p>
<p>设计中的应用</p>
<p>1.导航栏：我们可以随便打开一个网站，基本上绝大多数的网站导航栏中的选项都不会超过九个。即使超过九个选项，也会进行折叠或是用搜索框等方式进行分隔。而移动端的导航栏中选项多数不超过五个。</p>
<p>2.打开我们的通话记录，可以清楚看到11位的电话号码都被以3-4-4的形式分隔开。除此之外银行卡号被分隔也是同样的道理，方便用户查看。</p>
<p>总结</p>
<p>米勒定律与席克定律有共同点，均是为了减少用户的认知负荷。无论是把选项控制在某个数字内，还是进行隐藏或分类等操作，均是为了帮助用户更有效率的进行使用。</p>
<p>什么是奥卡姆剃刀原理</p>
<p>基本原理：把复杂的事情简单化。当一个简单的方案足够解决问题时，没有必要去寻求更复杂的方案。两个功能相同的产品，使用起来越简单的那一个往往更好。在不损害整体功能的情况下，删除那些无意义无价值的元素。</p>
<p>设计中的应用</p>
<p>1.苹果官网：打开网站，我们就可以清楚地看到新产品。主要的内容也都被以“块”的方式分隔开。看似没有很多的内容，但其实主要信息已经让用户知晓了。</p>
<figure data-type="image" tabindex="10"><img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6Yrh9JRKdrzFCTHRYjnynVQYiaXUmLf14ge9V9hXpMp5GWiaRx5b82UibyAlg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></figure>
<p>2.谷歌搜索：充分的贯彻了搜索引擎的定义。完美的去掉了其他无用的元素。更多功能被隐藏起来，不给用户过多的干扰。</p>
<figure data-type="image" tabindex="11"><img src="https://mmbiz.qpic.cn/mmbiz_png/3DWMyLrQK93FomXvvxVU1tS6VhTk6Yrhh4NW5jtQu8P6lHzAxaM0xMPM7A3j5S56KKMZES5WOtCIhPibYlvgUEg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></figure>
<p>总结<br>
现在极简风格依然在流行，奥卡姆剃刀原理起了很重要的作用。极简并不代表简陋，根本目的是让用户更加专心不被打扰的进行操作。为了达到这一点，我们可以去掉多余的字段、收起不重要的功能、减少用户点击次数等方式。</p>

        </div>

        


        <div class="flex justify-between py-8">
          

          
        </div>

        

      </div>
    </div>

    <script src="https://lseatao.github.io/8816/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
